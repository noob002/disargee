<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE MINORITY: NIGHTMARE (BALANCED)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --main-color: #33ff33;
            --bg-color: #050505;
        }

        body {
            background-color: #000;
            color: var(--main-color);
            font-family: 'VT323', monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            text-transform: uppercase;
            user-select: none;
            transition: color 1s ease;
        }

        body.mode-green { --main-color: #33ff33; }
        body.mode-yellow { --main-color: #ffcc00; }
        body.mode-red { --main-color: #ff3333; }
        body.mode-break { --main-color: #ffffff; }
        body.mode-clear { --main-color: #00ffff; }
        body.mode-gray { --main-color: #888888; }
        
        /* 악몽 테마 */
        body.mode-nightmare { --main-color: #b026ff; }
        
        /* 카오스 테마 (화면 움직일 때) */
        body.mode-chaos { --main-color: #00ffea; text-shadow: 2px 0 #ff00ff; }

        .crt-frame {
            border: 4px solid var(--main-color);
            padding: 30px;
            width: 700px;
            max-width: 95%;
            height: 550px;
            box-shadow: 0 0 20px var(--main-color), inset 0 0 50px rgba(0,0,0,0.8);
            background-color: var(--bg-color);
            position: relative; /* 기본: 중앙 정렬 */
            display: flex;
            flex-direction: column;
            transition: border-color 0.5s, box-shadow 0.5s;
            z-index: 10;
        }

        /* 카오스 모드일 때 미세한 떨림 (이전보다 약하게 수정) */
        .crt-frame.chaos-shake {
            animation: soft-shake 0.2s infinite;
        }

        @keyframes soft-shake {
            0% { transform: translate(0, 0); }
            50% { transform: translate(1px, 1px); }
            100% { transform: translate(-1px, -1px); }
        }

        .scanline {
            width: 100%; height: 100px;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 255, 255, 0.03) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1; position: absolute; bottom: 100%;
            animation: scanline 6s linear infinite; pointer-events: none; z-index: 999;
        }
        @keyframes scanline { 0% { bottom: 100%; } 100% { bottom: -100%; } }

        .header { display: flex; justify-content: space-between; border-bottom: 2px solid var(--main-color); padding-bottom: 10px; margin-bottom: 20px; font-size: 1.4rem; }
        .content-area { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; width: 100%; }

        button {
            background: transparent; border: 2px solid var(--main-color); color: var(--main-color);
            font-family: 'VT323', monospace; font-size: 1.8rem; padding: 10px 20px;
            cursor: pointer; margin: 10px; transition: 0.2s;
        }
        button:hover { background-color: var(--main-color); color: #000; }
        
        #skip-btn { display: none; border-style: dashed; font-size: 1.2rem; margin-top: 10px; opacity: 0.7; }
        
        #nightmare-btn {
            display: none; 
            border: 2px solid #b026ff; 
            color: #b026ff;
            margin-top: 20px;
            animation: pulse 1s infinite;
            font-weight: bold;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        #screen-phase1, #screen-phase2, #screen-phase3, #screen-end { display: none; width: 100%; text-align: center; }

        .question-text { font-size: 2rem; min-height: 80px; margin-bottom: 30px; }
        .result-bar-bg { width: 100%; height: 20px; background: #111; border: 1px solid var(--main-color); margin-top: 20px; display: none; }
        .result-bar-fill { height: 100%; background: var(--main-color); width: 0%; transition: width 0.5s; }
        .code-box { font-size: 4rem; letter-spacing: 15px; margin: 20px 0; border: 2px dashed var(--main-color); padding: 20px; }
        .hack-input { background: transparent; border: none; border-bottom: 3px solid var(--main-color); color: var(--main-color); font-size: 2.5rem; text-align: center; width: 80%; outline: none; text-transform: uppercase; }
        .timer-bg { width: 100%; height: 10px; background: #330000; margin-top: 30px; }
        .timer-fill { width: 100%; height: 100%; background: #ff3333; }

        #screen-phase3 { height: 100%; position: relative; }
        canvas { border: 2px solid var(--main-color); background: #000; cursor: none; display: block; margin: 0 auto; transition: border-color 0.2s; }
        .survival-timer { font-size: 2rem; margin-bottom: 10px; color: var(--main-color); transition: color 0.2s; }
        #break-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; text-align: center; font-size: 2rem; color: #fff;
            text-shadow: 0 0 10px #fff; display: none; pointer-events: none;
        }

        #screen-end { position: relative; height: 100%; }
        #end-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        .end-content { position: relative; z-index: 1; display: flex; flex-direction: column; justify-content: center; height: 100%; }
        .shine-text { font-size: 5rem; margin: 0; animation: shine 2s infinite alternate; }
        @keyframes shine {
            from { text-shadow: 0 0 10px var(--main-color); }
            to { text-shadow: 0 0 30px var(--main-color), 0 0 10px #fff; transform: scale(1.05); }
        }
        .blink { animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body class="mode-green">
    <div class="scanline"></div>

    <div class="crt-frame" id="game-frame">
        <div class="header">
            <span>LEVEL: <span id="stage-display">WAITING</span></span>
            <span>STATUS: <span id="status-display">OK</span></span>
        </div>

        <div class="content-area">
            <div id="screen-start" style="text-align: center;">
                <h1 style="font-size: 3rem;">THE MINORITY</h1>
                <p>최종 테스트를 시작합니다.</p>
                <button onclick="startPhase1()" class="blink">SYSTEM START</button>
                <br>
                <button id="nightmare-btn" onclick="startNightmare()">☠ NIGHTMARE ☠</button>
            </div>

            <div id="screen-phase1">
                <div class="question-text" id="p1-text"></div>
                <div id="p1-btns" style="display: flex; gap: 20px; justify-content: center;">
                    <button onclick="checkP1(true)">[Y] AGREE</button>
                    <button onclick="checkP1(false)">[N] DISAGREE</button>
                </div>
                <div id="p1-result">
                    <div class="result-bar-bg" id="bar-bg"><div class="result-bar-fill" id="bar-fill"></div></div>
                    <p id="p1-msg" style="margin-top:15px; height: 30px;"></p>
                    <button id="next-btn" onclick="nextPhase1()" style="display:none; width:100%;">NEXT >></button>
                </div>
            </div>

            <div id="screen-phase2">
                <h2 class="blink" style="color: #ff3333;">⚠ SECURITY BREACH ⚠</h2>
                <div class="code-box" id="p2-code">????</div>
                <input type="text" class="hack-input" id="p2-input" placeholder="TYPE CODE" onkeyup="checkP2(event)" autocomplete="off">
                <div class="timer-bg"><div class="timer-fill" id="p2-timer"></div></div>
                <p id="p2-info">DEFENSE: 0 / 3</p>
            </div>

            <div id="screen-phase3">
                <div class="survival-timer">TIME: <span id="dodge-timer">READY</span></div>
                <div style="position: relative;">
                    <canvas id="gameCanvas" width="600" height="350"></canvas>
                    <div id="break-overlay"></div>
                </div>
                <p style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                    MOUSE MOVE / AVOID OBJECTS
                </p>
            </div>

            <div id="screen-end">
                <canvas id="end-canvas"></canvas>
                <div class="end-content">
                    <h1 class="shine-text" id="end-title">ALL CLEAR</h1>
                    <p id="end-desc" style="font-size: 1.5rem; margin-top: 20px;">...</p>
                    
                    <button id="reboot-btn" onclick="location.reload()" style="margin-top: 40px;">SYSTEM REBOOT</button>
                    <button id="skip-btn" onclick="skipToEnding()">>> SKIP TO ENDING >></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* ================= UTILS ================= */
        function showScreen(id) {
            ['screen-start','screen-phase1','screen-phase2','screen-phase3','screen-end']
                .forEach(s => document.getElementById(s).style.display = 'none');
            document.getElementById(id).style.display = 'block';
        }
        function setTheme(mode) { document.body.className = `mode-${mode}`; }

        let failCount = parseInt(localStorage.getItem('minority_fail_count')) || 0;
        let isGameCleared = localStorage.getItem('minority_game_cleared') === 'true';

        window.onload = function() {
            if (isGameCleared) {
                document.getElementById('nightmare-btn').style.display = 'inline-block';
            }
        };

        let gameMode = 'normal'; 
        
        // 악몽 모드 이동 변수 (너프됨: 속도 감소)
        let chaosModeActive = false;
        let frameVelocity = { x: 2.5, y: 2.5 }; // [너프] 창 이동 속도 4 -> 2.5
        let framePos = { x: 0, y: 0 }; 

        /* ================= PHASE 1 & 2 ================= */
        function startNightmare() {
            gameMode = 'nightmare';
            startPhase3();
        }

        const questions = [
            { q: "비 오는 날이 맑은 날보다 좋다.", rate: 80 }, 
            { q: "10억 받기 vs 말하는 고양이 키우기", rate: 20 },
            { q: "솔직히 탕수육은 부먹이다.", rate: 45 },
        ];
        let p1Idx = 0;

        function startPhase1() {
            gameMode = 'normal'; 
            showScreen('screen-phase1');
            document.getElementById('stage-display').innerText = "1 - MINORITY";
            renderP1();
        }
        function renderP1() {
            const q = questions[p1Idx];
            document.getElementById('p1-text').innerText = q.q;
            document.getElementById('p1-btns').style.display = 'flex';
            document.getElementById('bar-bg').style.display = 'none';
            document.getElementById('next-btn').style.display = 'none';
            document.getElementById('p1-msg').innerText = "";
            document.getElementById('bar-fill').style.width = "0%";
        }
        function checkP1(agree) {
            const q = questions[p1Idx];
            const rate = agree ? q.rate : (100 - q.rate);
            document.getElementById('p1-btns').style.display = 'none';
            document.getElementById('bar-bg').style.display = 'block';
            setTimeout(() => document.getElementById('bar-fill').style.width = rate + "%", 50);
            if (rate < 50) {
                document.getElementById('p1-msg').innerText = `생존. 소수(${rate}%)입니다.`;
                document.getElementById('next-btn').style.display = 'inline-block';
            } else {
                failGame("MAJORITY DETECTED", "당신은 다수에 속했습니다.");
            }
        }
        function nextPhase1() {
            p1Idx++;
            if (p1Idx >= questions.length) startPhase2(); else renderP1();
        }

        /* PHASE 2 */
        let p2Score = 0;
        let p2TimerInterval;
        let p2Time = 100;

        function startPhase2() {
            setTheme('red');
            document.getElementById('stage-display').innerText = "2 - HACKING";
            document.getElementById('status-display').innerText = "WARNING";
            showScreen('screen-phase2');
            nextP2();
        }
        function nextP2() {
            if (p2Score >= 3) {
                clearInterval(p2TimerInterval);
                startPhase3();
                return;
            }
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let code = "";
            for(let i=0; i<4; i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
            document.getElementById('p2-code').innerText = code;
            document.getElementById('p2-input').value = "";
            document.getElementById('p2-input').focus();
            p2Time = 100;
            clearInterval(p2TimerInterval);
            p2TimerInterval = setInterval(() => {
                p2Time -= 1.5;
                document.getElementById('p2-timer').style.width = p2Time + "%";
                if (p2Time <= 0) { clearInterval(p2TimerInterval); failGame("SYSTEM HACKED", "방화벽이 뚫렸습니다."); }
            }, 50);
        }
        function checkP2(e) {
            if (e.key === "Enter") {
                if (document.getElementById('p2-code').innerText === document.getElementById('p2-input').value.toUpperCase()) {
                    p2Score++;
                    document.getElementById('p2-info').innerText = `DEFENSE: ${p2Score} / 3`;
                    nextP2();
                } else { document.getElementById('p2-input').value = ""; }
            }
        }

        /* ================= PHASE 3 ================= */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameLoopId;
        
        let p3TotalTime = 45.00;
        let player = { x: 300, y: 175, size: 10, color: '#fff' };
        let enemies = [];
        let warnings = [];
        let gameState = 'ready';
        let currentPhase = 'green';
        let countdownNum = 3;

        let typeWriterIdx = 0;
        let typeWriterText = "";
        let typeWriterInterval;

        function startPhase3() {
            showScreen('screen-phase3');
            
            enemies = []; warnings = [];
            gameState = 'ready'; countdownNum = 3;
            chaosModeActive = false;
            
            // 화면 이동 초기화
            const frame = document.getElementById('game-frame');
            frame.style.position = 'relative'; 
            frame.style.left = 'auto'; frame.style.top = 'auto';
            frame.classList.remove('chaos-shake');
            document.body.style.display = 'flex'; 

            if (gameMode === 'nightmare') {
                document.getElementById('stage-display').innerText = "☠ NIGHTMARE ☠";
                setTheme('nightmare');
                p3TotalTime = 60.00; 
                currentPhase = 'nightmare'; 
            } else {
                document.getElementById('stage-display').innerText = "3 - SURVIVAL";
                setTheme('green');
                p3TotalTime = 45.00;
                currentPhase = 'green';
            }

            document.getElementById('dodge-timer').innerText = "READY...";
            document.getElementById('break-overlay').style.display = 'none';

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                player.x = e.clientX - rect.left;
                player.y = e.clientY - rect.top;
            });

            const countInterval = setInterval(() => {
                if (countdownNum > 0) {
                    document.getElementById('dodge-timer').innerText = `START IN ${countdownNum}...`;
                    countdownNum--;
                } else {
                    clearInterval(countInterval);
                    gameState = 'playing';
                }
            }, 1000);

            if(gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function startTyping(text) {
            const overlay = document.getElementById('break-overlay');
            overlay.style.display = 'block';
            overlay.innerText = "";
            typeWriterText = text;
            typeWriterIdx = 0;
            clearInterval(typeWriterInterval);
            typeWriterInterval = setInterval(() => {
                if (typeWriterIdx < typeWriterText.length) {
                    overlay.innerText += typeWriterText.charAt(typeWriterIdx);
                    typeWriterIdx++;
                } else {
                    clearInterval(typeWriterInterval);
                }
            }, 100);
        }

        function updateChaosFrame() {
            const frame = document.getElementById('game-frame');
            if (!chaosModeActive) {
                chaosModeActive = true;
                const rect = frame.getBoundingClientRect();
                framePos.x = rect.left;
                framePos.y = rect.top;
                
                document.body.style.display = 'block'; 
                frame.style.position = 'absolute';
                frame.style.margin = '0';
                frame.style.left = framePos.x + 'px';
                frame.style.top = framePos.y + 'px';
                
                setTheme('chaos');
                frame.classList.add('chaos-shake');
                document.getElementById('status-display').innerText = "ERROR!!";
            }

            framePos.x += frameVelocity.x;
            framePos.y += frameVelocity.y;

            if (framePos.x <= 0 || framePos.x + frame.offsetWidth >= window.innerWidth) {
                frameVelocity.x *= -1;
            }
            if (framePos.y <= 0 || framePos.y + frame.offsetHeight >= window.innerHeight) {
                frameVelocity.y *= -1;
            }

            frame.style.left = framePos.x + 'px';
            frame.style.top = framePos.y + 'px';
        }

        function gameLoop() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = (gameMode === 'nightmare') ? "#b026ff" : "#ffffff";
            if(chaosModeActive) ctx.fillStyle = "#00ffea";

            ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
            ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
            ctx.shadowBlur = 0;

            if (gameState === 'ready') {
                ctx.fillStyle = "#ffffff"; ctx.font = "40px VT323"; ctx.textAlign = "center";
                ctx.fillText(countdownNum > 0 ? countdownNum : "GO!", canvas.width/2, canvas.height/2);
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }

            p3TotalTime -= 0.016;
            document.getElementById('dodge-timer').innerText = p3TotalTime.toFixed(2);

            // === 악몽 모드 로직 ===
            if (gameMode === 'nightmare') {
                // [너프] 40초 -> 30초 남았을 때부터 움직임
                if (p3TotalTime <= 30) { 
                    updateChaosFrame();
                }
                if (p3TotalTime <= 0) { cancelAnimationFrame(gameLoopId); gameClear(); return; }
            } else {
                // 노말 모드 로직
                let newPhase = currentPhase;
                if (p3TotalTime > 30) newPhase = 'green';
                else if (p3TotalTime > 25) newPhase = 'break1';
                else if (p3TotalTime > 10) newPhase = 'yellow';
                else if (p3TotalTime > 5) newPhase = 'break2';
                else if (p3TotalTime > 0) newPhase = 'red';
                else { cancelAnimationFrame(gameLoopId); gameClear(); return; }

                if (newPhase !== currentPhase) {
                    currentPhase = newPhase;
                    if (currentPhase === 'break1') { setTheme('break'); enemies=[]; warnings=[]; startTyping("SYSTEM UPGRADE..."); }
                    else if (currentPhase === 'break2') { setTheme('break'); enemies=[]; warnings=[]; startTyping("당신은 과연 이 이상을 깰 수 있을까?"); }
                    else if (currentPhase === 'green') { setTheme('green'); document.getElementById('break-overlay').style.display='none'; }
                    else if (currentPhase === 'yellow') { setTheme('yellow'); document.getElementById('break-overlay').style.display='none'; }
                    else if (currentPhase === 'red') { setTheme('red'); document.getElementById('break-overlay').style.display='none'; }
                }
            }

            if (!currentPhase.includes('break')) spawnPattern(currentPhase);

            // 경고선 처리
            for (let i = warnings.length - 1; i >= 0; i--) {
                let w = warnings[i];
                w.timer--;
                if (w.timer > 0) {
                    ctx.save(); ctx.beginPath(); ctx.setLineDash([10, 10]);
                    
                    let warnColor = "#ffcc00"; 
                    if(gameMode === 'nightmare') warnColor = "#b026ff"; 
                    if(chaosModeActive) warnColor = "#00ffea"; 
                    
                    ctx.strokeStyle = (Math.floor(Date.now()/50)%2===0) ? warnColor : "#222";
                    ctx.lineWidth = 2; ctx.moveTo(w.x, 0); ctx.lineTo(w.x, canvas.height); ctx.stroke(); ctx.restore();
                } else {
                    let speed = (currentPhase === 'red') ? 6 : 5;
                    // [너프] 악몽 탄막 속도: 11 -> 7.5 (보고 피할 수준)
                    if (gameMode === 'nightmare') speed = 7.5; 

                    let color = '#ff0000';
                    if (gameMode === 'nightmare') color = '#b026ff';
                    if (chaosModeActive) color = '#00ffea';

                    enemies.push({ x: w.x - (w.width/2), y: -50, size: w.width, speed: speed, type: 'blitz', color: color });
                    warnings.splice(i, 1);
                }
            }

            // 적 처리
            for (let i = 0; i < enemies.length; i++) {
                let e = enemies[i];
                e.y += e.speed;
                ctx.fillStyle = e.color;
                let height = (e.type === 'blitz') ? canvas.height : e.size; 
                ctx.fillRect(e.x, e.y, e.size, height);

                if (player.x < e.x + e.size && player.x + player.size > e.x && player.y < e.y + height && player.y + player.size > e.y) {
                    cancelAnimationFrame(gameLoopId);
                    failGame("KILLED", "생존에 실패했습니다.");
                    return;
                }
            }
            if (enemies.length > 50) enemies.shift();
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function spawnPattern(phase) {
            if (gameMode === 'nightmare') {
                // 악몽 모드 (밸런스 패치 적용)
                let spawnRateWarn = 0.08;
                let spawnRateEnemy = 0.1;

                if (chaosModeActive) { // 카오스 때는 조금 덜 나오게
                    spawnRateWarn = 0.05;
                    spawnRateEnemy = 0.06;
                }
                
                // [너프] 경고 시간: 50 -> 80 (약 1.3초, 충분히 반응 가능)
                if (Math.random() < spawnRateWarn) warnings.push({ x: Math.random() * canvas.width, width: 30, timer: 80, active: true }); 
                
                // [너프] 일반 적 속도: 7 -> 5
                if (Math.random() < spawnRateEnemy) enemies.push({ x: Math.random() * canvas.width, y: -20, size: Math.random() * 15 + 10, speed: 5, type: 'normal', color: chaosModeActive ? '#00ffea' : '#b026ff' });
                return;
            }

            // 노말 모드 (너프 버전)
            if (phase === 'green') {
                if (Math.random() < 0.05) enemies.push({ x: Math.random() * canvas.width, y: -20, size: Math.random() * 15 + 10, speed: (Math.random() * 2 + 1), type: 'normal', color: '#33ff33' });
            } else if (phase === 'yellow') {
                if (Math.random() < 0.04) warnings.push({ x: Math.random() * canvas.width, width: 25, timer: 90, active: true });
            } else if (phase === 'red') {
                if (Math.random() < 0.05) warnings.push({ x: Math.random() * canvas.width, width: 30, timer: 100, active: true });
                if (Math.random() < 0.08) enemies.push({ x: Math.random() * canvas.width, y: -20, size: Math.random() * 15 + 10, speed: (Math.random() * 2 + 2), type: 'normal', color: '#ff3333' });
            }
        }

        /* ================= GAME OVER / ENDING ================= */
        
        function failGame(title, desc) {
            failCount++; 
            localStorage.setItem('minority_fail_count', failCount);
            
            showScreen('screen-end');
            setTheme('red');
            document.getElementById('end-canvas').style.display = 'none'; 
            
            const titleEl = document.getElementById('end-title');
            titleEl.innerText = title;
            titleEl.className = "big-msg"; 
            titleEl.style.color = "red";
            
            document.getElementById('end-desc').innerText = desc;

            if (failCount >= 5) {
                document.getElementById('skip-btn').style.display = 'inline-block';
            } else {
                document.getElementById('skip-btn').style.display = 'none';
            }

            clearInterval(p2TimerInterval);
            if(gameLoopId) cancelAnimationFrame(gameLoopId);
        }

        function skipToEnding() {
            localStorage.removeItem('minority_fail_count');
            showScreen('screen-end');
            setTheme('gray');
            document.getElementById('end-canvas').style.display = 'none'; 
            document.getElementById('skip-btn').style.display = 'none'; 
            document.getElementById('end-title').innerText = "SKIPPED";
            document.getElementById('end-title').className = "big-msg"; 
            document.getElementById('end-title').style.color = "#888"; 
            document.getElementById('end-desc').innerText = "평범한 결말입니다. 다시 도전하시겠습니까?";
        }

        function gameClear() {
            localStorage.removeItem('minority_fail_count');
            
            if (gameMode === 'normal') {
                localStorage.setItem('minority_game_cleared', 'true');
            }

            showScreen('screen-end');
            document.getElementById('skip-btn').style.display = 'none';
            document.getElementById('end-canvas').style.display = 'block';

            const titleEl = document.getElementById('end-title');
            const descEl = document.getElementById('end-desc');
            const statusEl = document.getElementById('status-display');

            if (gameMode === 'nightmare') {
                setTheme('chaos');
                titleEl.innerText = "GOD MODE";
                titleEl.style.color = "#00ffea";
                descEl.innerText = "당신은 악몽을 지배했습니다.";
                statusEl.innerText = "GOD";
            } else {
                setTheme('clear');
                titleEl.innerText = "ALL CLEAR";
                titleEl.style.color = "#00ffff";
                descEl.innerText = "축하합니다. 모든 테스트를 통과했습니다.";
                statusEl.innerText = "LEGEND";
            }
            titleEl.className = "shine-text";
            startFireworks();
        }

        /* FIREWORKS */
        let fireworks = [], particles = [], endCtx, endCanvas;
        function startFireworks() {
            endCanvas = document.getElementById('end-canvas');
            endCtx = endCanvas.getContext('2d');
            endCanvas.width = endCanvas.offsetWidth; endCanvas.height = endCanvas.offsetHeight;
            fireworks = []; particles = [];
            loopFireworks();
        }
        function loopFireworks() {
            endCtx.clearRect(0, 0, endCanvas.width, endCanvas.height);
            if (Math.random() < 0.05) {
                fireworks.push({
                    x: Math.random() * endCanvas.width, y: endCanvas.height,
                    targetY: Math.random() * (endCanvas.height / 2),
                    speed: 10 + Math.random() * 5, color: `hsl(${Math.random() * 360}, 100%, 50%)`
                });
            }
            for (let i = fireworks.length - 1; i >= 0; i--) {
                let f = fireworks[i]; f.y -= f.speed;
                endCtx.fillStyle = f.color; endCtx.fillRect(f.x, f.y, 4, 10);
                if (f.y <= f.targetY) { explode(f.x, f.y, f.color); fireworks.splice(i, 1); }
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.alpha -= 0.01;
                endCtx.save(); endCtx.globalAlpha = p.alpha; endCtx.fillStyle = p.color;
                endCtx.fillRect(p.x, p.y, 4, 4); endCtx.restore();
                if (p.alpha <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(loopFireworks);
        }
        function explode(x, y, color) {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 5 + 2;
                particles.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, alpha: 1, color: color });
            }
        }
    </script>
</body>
</html>
